{"name":"2015btrans.GitHub.io","tagline":"botball github page","body":"````### Welcome to GitHub Pages.\r\nThis automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here using GitHub Flavored Markdown, select a template crafted by a designer, and publish. After your page is generated, you can check out the new branch:\r\n\r\n```\r\n#include <stdio.h>\r\n\r\nvoid forward(int, int);\r\nvoid backward(int, int);\r\nvoid turnleft(int, int);\r\nvoid turnright(int, int);\r\nvoid opencubewall();\r\nvoid closecubewall();\r\nvoid pulleyup(int);\r\nvoid pulleydown(int);\r\nvoid tiltdown();\r\nvoid tiltup();\r\n\r\n// Sensor ports\r\n#define START_LIGHT_PORT 0\r\n\r\n// Servo ports\r\n#define CUBE_WALL_PORT 2\r\n\r\n// Motor ports\r\n#define LEFT_MOTOR 2\r\n#define RIGHT_MOTOR 1\r\n#define PULLEY_MOTOR 3\r\n#define TILT_MOTOR 0\r\n\r\n// Other\r\n#define DIAMETER 1000\r\n#define PI 3.141592653589793238462643385027\r\n\r\n\r\n/*\r\nThis program is meant to provide a framework as well basic mobility functions for the Lego robot. This program will refer to the Lego by his name, Wall-E.\r\n*/\r\nint main()\r\n{\r\n\t//start right ski 2.75 inches from the side wall\r\n\t//\r\n\t//\r\n\t//Waiting to start\t\r\n\t\r\n\t//wait_for_light(START_LIGHT_PORT);\r\n\tshut_down_in(120);\r\n\t// 3700 3700 3700 3700 3700\r\n\t//\r\n\t//Game tasks\r\n\t//\r\n\t//Drive forward to wall\r\n\tbackward(400, 1000);\r\n\r\n\tforward(5600, 1000);\r\n\tbackward(100, 500);\r\n\t\r\n\t//Get orange cubes\r\n\tpulleyup(4000);\r\n\tturnleft(82, 300);\r\n\topencubewall();\r\n\tforward(2000, 500);\r\n\tbackward(450, 500);\r\n\tpulleydown(400);\r\n\tmsleep(500);\r\n\tturnright(40, 500);\r\n\tmsleep(500);\r\n\tclosecubewall();\r\n\tmsleep(500);\r\n\t\r\n\t//Upper storage area\r\n\tturnleft(95, 500);\r\n\tforward(2300, 1000);\r\n\tpulleydown(3600);\r\n\tturnleft(90, 500);\r\n\tforward(1800, 1000);\r\n\ttiltdown();\r\n\tmsleep(2000);\r\n\topencubewall();\r\n\t\r\n}\r\n\r\n/*\r\nThis function takes two ints.\r\ndist is the distance that Wall-E will move in ticks.\r\nspeed is the speed at which Wall-E will move in ticks/s. speed is in the interval, [0, 1000].\r\n*/\r\nvoid forward(int dist, int speed)\r\n{\r\n\tint rightspeed = speed;\r\n\tint leftspeed = rightspeed * .98;\r\n\tint initdist = 100;\r\n\tmove_relative_position(LEFT_MOTOR, leftspeed, dist);\r\n\tmove_relative_position(RIGHT_MOTOR, rightspeed, -1 * dist); //This is negative b/c the motor will be upside down\r\n\twhile(!get_motor_done(LEFT_MOTOR) && !get_motor_done(RIGHT_MOTOR))\r\n\t\tmsleep(10);\r\n\toff(LEFT_MOTOR);    // Don't use ao() because the pulley motor needs to stay on to freeze\r\n\toff(RIGHT_MOTOR);\r\n}\r\n\r\n/*\r\nThis function takes two ints.\r\ndist is the distance that Wall-E will move in ticks.\r\nspeed is the speed at which Wall-E will move in ticks/s. speed is in the interval, [0, 1000].\r\n*/\r\nvoid backward(int dist, int speed)\r\n{\r\n\tint rightspeed = speed;\r\n\tint leftspeed = rightspeed * .92;\r\n\tmove_relative_position(LEFT_MOTOR, leftspeed, -1 * dist);\r\n\tmove_relative_position(RIGHT_MOTOR, rightspeed, dist); //This is negative b/c the motor will be upside down\r\n\twhile(!get_motor_done(LEFT_MOTOR) || !get_motor_done(RIGHT_MOTOR))\r\n\t\tmsleep(10);\r\n\toff(LEFT_MOTOR);\r\n\toff(RIGHT_MOTOR);\r\n}\r\n\r\n/*\r\nThis function takes two ints.\r\nangle is the number of degrees that Wall-E will turn.\r\nspeed is the speed at which Wall-E will move in tick/s. speed is in the interval, [0, 1000].\r\n*/\r\nvoid turnright(int angle, int speed)\r\n{\r\n\tint ticks;\r\n\tangle -= 30;\r\n\tdouble alpha = /*5.7777777777777777777777777777779*/ 1;\r\n\t\r\n\tticks = (int)(alpha * (angle * (PI / 180)) * (DIAMETER / 2));\r\n\t\r\n\tmove_relative_position(RIGHT_MOTOR, speed, ticks);\r\n\tmove_relative_position(LEFT_MOTOR, speed, ticks);\r\n\twhile(!get_motor_done(RIGHT_MOTOR) && !get_motor_done(LEFT_MOTOR))\r\n\t\tmsleep(10);\r\n\toff(LEFT_MOTOR);\r\n\toff(RIGHT_MOTOR);\r\n}\r\n\r\n/*\r\nThis function takes two ints.\r\nangle is the number of degrees that Wall-E will turn.\r\nspeed is the speed at which Wall-E will move in tick/s. speed is in the interval, [0, 1000].\r\n*/\r\nvoid turnleft(int angle, int speed)\r\n{\r\n\tint ticks;\r\n\tangle -= 30;\r\n\tdouble alpha = /*5.9777777777777777777777777777779*/ 1;\r\n\t\r\n\tticks = (int)(alpha * (angle * (PI / 180)) * -(DIAMETER / 2));\r\n\t\r\n\tmove_relative_position(LEFT_MOTOR, -1 * speed, ticks);\r\n\t//move_relative_position(RIGHT_MOTOR, (int)(.01 * speed), ticks);\r\n\tmove_relative_position(RIGHT_MOTOR, -1 * speed, ticks);\r\n\twhile(!get_motor_done(LEFT_MOTOR) && !get_motor_done(RIGHT_MOTOR))\r\n\t\tmsleep(10);\r\n\toff(LEFT_MOTOR);\r\n\toff(RIGHT_MOTOR);\r\n}\r\n\r\nvoid opencubewall()\r\n{\r\n\tset_servo_position(CUBE_WALL_PORT, 2000);\r\n\tenable_servo(CUBE_WALL_PORT);\r\n\tmsleep(1500);\r\n}\r\n\r\nvoid closecubewall()\r\n{\r\n\tset_servo_position(CUBE_WALL_PORT, 0);\r\n\tenable_servo(CUBE_WALL_PORT);\r\n\tmsleep(1500);\r\n}\r\n\r\nvoid pulleydown(int dist)\r\n{\r\n\tmove_relative_position(PULLEY_MOTOR, 400, dist);\r\n\tblock_motor_done(PULLEY_MOTOR);\r\n\toff(PULLEY_MOTOR);\r\n}\r\n\r\nvoid pulleyup(int dist)\r\n{\r\n    move_relative_position(PULLEY_MOTOR, 400, -1 * dist);\r\n\tblock_motor_done(PULLEY_MOTOR);\r\n\tfreeze(PULLEY_MOTOR);\r\n}\r\n\r\nvoid tiltdown()\r\n{\r\n\tmove_relative_position(TILT_MOTOR, 200, -250);\r\n\tblock_motor_done(TILT_MOTOR);\r\n\toff(TILT_MOTOR);\r\n}\r\n\r\nvoid tiltup()\r\n{\r\n\tmove_relative_position(TILT_MOTOR, 200, 250);\r\n\tblock_motor_done(TILT_MOTOR);\r\n\toff(TILT_MOTOR);\r\n}\r\n\r\n\r\n\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}